
# Because arrays are passed by value, this function is more verbose than the equivalent C might be!
SUBROUTINE quicksort(ary)

	# If the array is empty or has 1 element, it is sorted!
	IF (LEN(ary) < 2) THEN
		RETURN ary
	ENDIF

	# Choose a pivot value and place in first element.
	pivot <- LEN(ary) DIV 2
	tmp <- ary[pivot]
	ary[pivot] <- ary[0]
	ary[0] <- tmp

	# Compare elements with pivot and partition.
	lastElement <- 0
	FOR i <- 1 TO LEN(ary)-1
		# compare this element with the pivot and swap if necessary
		IF (ary[i] < ary[0]) THEN
			lastElement <- lastElement + 1
			tmp <- ary[lastElement]
			ary[lastElement] <- ary[i]
			ary[i] <- tmp
		ENDIF
	ENDFOR

	# Restore the pivot
	tmp <- ary[lastElement]
	ary[lastElement] <- ary[0]
	ary[0] <- tmp

	# Call again on smaller elements
	smaller <- []
	FOR i <- 0 TO lastElement-1
		smaller[LEN(smaller)] <- ary[i]
	ENDFOR
	smaller <- quicksort(smaller)

	# Call again on bigger elements
	bigger <- []
	FOR i <- lastElement TO LEN(ary)-1
		bigger[LEN(bigger)] <- ary[i]
	ENDFOR
	bigger <- quicksort(bigger)

	# create result array
	result <- []
	FOR i <- 0 TO LEN(smaller)-1
		result[LEN(result)] <- smaller[i]
	ENDFOR

	FOR i <- 0 TO LEN(bigger)-1
		result[LEN(result)] <- bigger[i]
	ENDFOR

	RETURN result
ENDSUBROUTINE

# Build an array with some values to sort.
ary <- [93, 254, 1, 13, 12]

INSPECT ary
INSPECT quicksort(ary)

